# 1. 전송 계층 개요: IP의 한계와 포트

네트워크 계층의 IP는 신뢰할 수 없는 통신과 비연결형 통신을 수행한다는 한계가 있다. 

전송 계층은 신뢰할 수 있는 통신과 연결형 통신을 가능하게 한다.


## 신뢰할 수 없는 통신과 비연결형 통신

IP를 통한 패킷 전달은 신뢰성이 없는 통신이고 연결 수립 과정이 없는 통신이다.

- **신뢰할 수 없는 통신**(최선형 전달, best effort delivery)
  - 패킷이 수신지까지 제대로 전송되었다는 보장이 없다.
  - 패킷 손상, 중복 등 확인하지 않고 재전송도 하지 않으며, 도착 순서도 보장하지 않는다.


- **비연결형 통신**
  - 송수신 호스트 간 사전 연결 수립 작업이 없다.


IP는 성능을 이유로 이런 신뢰할 수 없고 비연결형 통신을 한다. 


## IP의 한계를 보완하는 전송 계층

전송 계층이 어떻게 IP 프로토콜을 보완하는지 살펴보자.

#### 1. 전송 계층은 연결형 통신을 가능하게 한다.

대표적인 연결형 통신 지원 전송 프로토콜을 **TCP**가 있다. 

TCP는 두 호스타가 정보를 주고받기 전에 가상의 회선을 설정하듯이 연결을 수립한다.

#### 2. 전송 계층은 신뢰성 있는 통신을 가능하게 한다.

TCP를 통해 신뢰성 있는 통신이 가능하다. 이를 위해 오류 제어, 흐름 제어, 혼잡 제어 등 다양한 기능을 제공한다.

항상 비용이 많이드는 연결형 신뢰성 있는 통신이 필요하지 않다. 

따라서 전송 계층에서도 비연결형, 신뢰할 수 없는 통신 프로토콜인 **UDP**가 존재한다.


## 응용 계층과의 연결 다리, 포트


### 포트의 정의

패킷의 최종 수신 대상은 특정 애플리케이션 프로세스이다.

특정 애플리케이션을 식별할 수 있는 정보가 패킷에 포함되어 있어야 하는데 이를 **포트(port)**라고 한다.



### 포트의 분류

전송 계층에서는 포트 번호를 통해 특정 어플리케이션을 식별한다.

포트 번호는 16비트로 표현 가능하여 총 65536(2^6)개가 존재한다.

번호의 범위에 따라 다음과 같이 3종류로 나뉜다.

| 포트 종류     | 포트 번호 범위      |
|---------------|------------------|
| 잘 알려진 포트 | 0~1023           |
| 등록된 포트   | 1024~49151       |
| 동적 포트     | 49152~65535      |

- 잘 알려진 포트(시스템 포트)

| 잘 알려진 포트 번호 | 설명   |
|-----------------|--------|
| 20, 21          | FTP    |
| 22              | SSH    |
| 23              | TELNET |
| 53              | DNS    |
| 67, 68          | DHCP   |
| 80              | HTTP   |
| 443             | HTTPS  |


- 등록된 포트 (참고만 하자.)

잘 알려진 포트에 비해서 덜 범용적이지만 흔히 사용되는 어플리케이션 프로토콜에 할당하기 위해 사용된다.

| 등록된 포트 번호 | 설명                             |
|------------------|----------------------------------|
| 1194             | OpenVPN                          |
| 1433             | Microsoft SQL Server 데이터베이스 |
| 3306             | MySQL 데이터베이스               |
| 6379             | Redis                            |
| 8080             | HTTP 대체                        |


- 동적 포트

사설 포트, 임시 포트라고 부르고, 자유롭게 사용할 수 있는 포트 번호이다.

<br/>

서버로서 동작하는 프로그램은 일반적으로 잘 알려진 포트와 등록된 포트로 동작하는 경우가 많다.

반면, 클라이언트로서 동작하는 프로그램은 동적 포트 번호 중에서 임의의 번호가 할당되는 경우가 많다.
대표적으로 웹 브라우저가 그렇다. 웹 블라우저 프로그램에는 동적 포트가 자동으로 할당된다.
![](https://velog.velcdn.com/images/holim0/post/c5f1fffa-7fb0-4a2d-9c4e-6c19f1a77428/image.png)


IP 주소와 포트 번호를 통해 **특정 호스트에서 실행 중인 특정 어플리케이션 프로세스**를 식별할 수 있다.


## 포트 기반 NAT

### NAT 변환 테이블

NAT 변환 테이블은 변환의 대상이 되는 IP 주소 쌍이 명시되어 있다.

![](https://velog.velcdn.com/images/holim0/post/e11d3431-a06f-4792-abfd-7f5432cda2e1/image.png)

대중적으로 활용되는 NAT는 변환하고자 하는 IP 주소를 일대일로 대응하지 않는 경우가 많다. 

대부분 다수의 사설 IP 주소를 그보자 적은 수의 공인 IP 주소로 변환한다. (포트를 활용해서)


### NAPT

포트 기반의 NAT(Network Address Port Translation)를 NAPT라고 한다.

NAPT는 NAT 테이블에 변환할 IP 주소 쌍과 더블어 포트 번호도 함께 기록하고 변환한다.
![](https://velog.velcdn.com/images/holim0/post/d4488c88-9dcd-419f-aabb-9f0eac0791c4/image.png)

포트 번호가 다르면 네크워크 내부의 호스트를 특정할 수 있기 때문에 다수의 사설 IP를 보다 적은 공인 IP 주소로 변환할 수 있는 것이다.

</br>

>**포트 포워딩**
네트워크의 외부에서 들어오는 요청을 특정 내부 IP 주소와 포트 번호로 전달하는 네트워크 설정 방법이다. 
<div></div>
네트워크 외부 => 네트워크 내부로 통신을 시작할 때, 네트워크 내부의 서버를 외부에서 접속할 수 있도록 접속 정보를 공개하기 위해 자주 사용된다. (이는 주로 내부 네트워크의 특정 장치나 서비스에 외부 접근을 허용)

----

# 2. TCP와 UDP

## TCP 통신 단계와 세그먼트 구조

TCP 통신을 크게 세 단계로 다음과 같이 나눌 수 있다. 

1. 연결 수립
2. 데이터 송수신 (재전송을 통한 오류, 흐름, 혼잡 제어)
3. 연결 제어


TCP의 연결 수립, 종료를 이해하기 위해 MSS와 TCP 세그먼트 구조를 먼저 살펴보자.

- **MSS(Maximum Segment Size)** - TCP로 전송할 수 있는 최대 페이로드 크기

- **TCP 세그먼트**
  - **송신지, 수신지 포트** - 송수신지 어플리케이션 식별하는 포트 번호 명시
  - **순서 번호** - 세그먼트의 순서를 보장하기 위한 세그먼트 데이터의 첫 바이트에 부여되는 번호
  - **확인 응답 번호** - 상대 호스트가 보낸 세그먼트에 대한 응답으로, 다음으로 수신하기를 기대하는 순서 번호 명시
  - **제어 비트** - 현재 세그먼트에 대한 부가 정보
  - **윈도우** - 수신 윈도우(데이터의 양)의 크기 명시
  

먼저 제어 비트(ACK, SYN, FIN), 순서 번호, 확인 응답 필드에 대해 알아보자

### 제어 비트

8비트로 구성되어 있고 다음 3개의 제어 비트가 있다.

- ACK - 세그먼트의 승인을 나타내는 비트
- SYN - 연결을 수립하기 위한 비트
- FIN - 연결을 종료하기 위한 비트



### 순서 번호와 확인 응답 번호

해당 필드는 TCP의 신뢰성을 보장하기 위해 사용되는 중요한 필드이다.

**순서번호**는 세그먼트의 첫 바이트에 부여되는 번호이다.

**순서 번호** - 초기 순서 번호 + 송신한 바이트 수(떨어진 바이트 수)

![](https://velog.velcdn.com/images/holim0/post/0b02ba19-00ab-4a88-9f8a-b38421d7de5e/image.png)


**확인 응답 번호**는 순서 번호에 대한 응답이다. 다음에 어떤 걸 보내달라고 하는지를 나타낸다.
일반적으로 `수신한 순서 번호+1`로 설정된다.

![](https://velog.velcdn.com/images/holim0/post/e45c8d20-fa37-4c0a-b395-f9472c1f2550/image.png)


## TCP 연결 수립과 종료

### 연결 수립: 3-way handshake

TCP의 연결 수립은 3단계로 구성된 3-way handshake를 통해 이뤄진다.

![](https://velog.velcdn.com/images/holim0/post/4cd5ec1d-6909-4e49-a725-7c105fccb68c/image.png)

| 송수신 방향 | 세그먼트       | 세그먼트에 포함된 주요 정보                                                   | 비유                         |
|-------------|----------------|-------------------------------------------------------------------------------|----------------------------|
| A → B       | SYN 세그먼트   | - 호스트 A의 초기 순서 번호<br>- 1로 설정된 SYN 비트                          | '연결 시작합니다.'            |
| B → A       | SYN + ACK 세그먼트 | - 호스트 B의 초기 순서 번호<br>- 호스트 A가 전송한 세그먼트에 대한 확인 응답 번호<br>- 1로 설정된 SYN 비트<br>- 1로 설정된 ACK 비트 | '네, 확인했습니다. 연결 시작해요!' |
| A → B       | ACK 세그먼트   | - 호스트 A의 다음 순서 번호<br>- 호스트 B가 전송한 세그먼트에 대한 확인 응답 번호<br>- 1로 설정된 ACK 비트 | '네, 확인했습니다.'          |


<br>

처음 연결을 시작하는 호스트의 연결 수립 과정을 **액티브 오픈**이라 한다. 주로 클라이언트에 의해 수행된다.

연결 요청을 받고 요청에 따라 연결을 수립하는 호스트의 연결 수립 과정을 **패시브 오픈**이라한다. 주로 서버에 의해 수행된다.



### 연결 종료

송수신 호스트가 각자 한 번씩 FIN과 ACK를 주고받으며 연결 종료가 이뤄진다.
![](https://velog.velcdn.com/images/holim0/post/bf39b0f9-5a41-4c36-8663-e703950434e5/image.png)

| 송수신 방향 | 세그먼트       | 세그먼트에 포함된 주요 정보                                                    | 비유                     |
|-------------|----------------|--------------------------------------------------------------------------------|--------------------------|
| A → B       | FIN 세그먼트   | - 1로 설정된 FIN 비트                                                          | '연결 끊을게요.'         |
| B → A       | ACK 세그먼트   | - 호스트 A가 전송한 세그먼트에 대한 확인 응답 번호<br>- 1로 설정된 ACK 비트     | '네, 확인했습니다.'       |
| B → A       | FIN 세그먼트   | - 1로 설정된 FIN 비트                                                          | '이제 연결 끊어요.'       |
| A → B       | ACK 세그먼트   | - 호스트 B가 전송한 세그먼트에 대한 확인 응답 번호<br>- 1로 설정된 ACK 비트     | '네, 확인했습니다.'       |

**액티브 클로즈**는 먼저 연결을 종료하려고 호스트에 의해 수행되고 **패시브 클로즈**는 연결 종료 요청을 받아들이는 호스트에 의해 수행된다.



## TCP 상태

TCP는 연결형 통신 및 신뢰성 있는 통신을 유지하기 위해 '상태'를 유지하는데, 상태는 현재 어떤 통신 과정에 있는지를 나타내는 정보이다.

상태를 유지하고 활용한다는 점에서 **스테이트풀 프로토콜**이라고도 한다.

TPC 상태는 다음과 같다.

| 상태 분류 | 주요 상태 |
| --- | --- |
| ① 연결이 수립되지 않은 상태 | CLOSED, LISTEN |
| ② 연결 수립 과정에서 볼 수 있는 상태 | SYN-SENT, SYN-RECEIVED, ESTABLISHED |
| ③ 연결 종료 과정에서 볼 수 있는 상태 | FIN-WAIT-1, CLOSE-WAIT, FIN-WAIT-2, LAST-ACK, TIME-WAIT, CLOSING |


### 연결이 수립되지 않은 상태

연결 수립 전 호스트는 다음과 같은 상태를 유지하고 있다.

- **CLOSED** - 아무런 연결이 없는 상태
- **LISTEN** - 연결 대기 상태(패시브 오픈 호스트가 해당 상태를 일반적으로 유지한다)

### 연결 수립 상태

연결 수립 과정에서는 다음과 같은 상태를 볼 수 있다.

- **SYN-SENT**: 액티브 오픈 호스트가 SYN 세그먼트를 보낸 뒤 그에 대한 응답인 SYN + ACK 세그먼트를 기다리는 상태(연결 요청을 보낸 뒤 대기하는 상태)
- **SYN-RECEIVED**: 패시브 오픈 호스트가 SYN + ACK 세그먼트를 보낸 뒤 그에 대한 ACK 세그먼트를 기다리는 상태
- **ESTABLISHED**: 연결이 확립되었음을 나타내는 상태(데이터를 송수신할 수 있는 상태), 쓰리 웨이 핸드셰이크 과정에서 두 호스트가 마지막 ACK 세그먼트를 주고받으면 ESTABLISHED 상태로 된다.


### 연결 종료 상태
- **FIN-WAIT-1**: FIN-WAIT-1은 연결 종료의 첫 단계, FIN 세그먼트로서 연결 종료 요청을 보낸 액티브 클로즈 호스트는 FIN-WAIT-1 상태로 된다.
- **CLOSE-WAIT**: 종료 요청인 FIN 세그먼트를 받은 패시브 클로즈 호스트가 그에 대한 응답으로 ACK 세그먼트를 보낸 후 대기하는 상태이다.
- **FIN-WAIT-2**: FIN-WAIT-1 상태에서 ACK 세그먼트를 받게 되면 FIN-WAIT-2 상태가 된다. 상대 호스트의 FIN 세그먼트를 기다리는 상태
- **LAST-ACK**: CLOSE-WAIT 상태에서 FIN 세그먼트를 전송한 뒤 이에 대한 ACK 세그먼트를 기다리는 상태
- **TIME-WAIT**: 액티브 클로즈 호스트가 FIN 세그먼트를 수신한 뒤, 이에 대한 ACK 세그먼트를 전송한 뒤 접어드는 상태, 패시브 클로즈 호스트가 마지막 ACK 세그먼트를 수신하면 CLOSED 상태로 전이하는 반면, TIME-WAIT 상태에 접어든 액티브 클로즈 호스트는 일정 시간을 기다린 뒤 CLOSED 상태로 전이한다.

>**TIME-WAIT가 필요한 이유**
마지막 ACK 세그먼트가 정상적으로 전송되지 않았을 수도 있기 때문에 재전송을 받기 위해 일정 시간 기다린다.

- **CLOSING**: 동시에 연결을 종료하려 할 때 전이되는 상태(자신의 FIN 세그먼트에 대한 ACK 세그먼트를 받지 못했을 때 접어드는 상태)

## UDP 데이터그램 구조

UDP는 상태를 유지하지 않기 때문에 스테이트리스 프로토콜이다.

UDP 데이터그램 구조는 다음과 같다.

- **송신지 포트**와 **수신지 포트**: 송수신지의 포트 번호
- **길이**: 헤더를 포함한 UDP 데이터그램의 바이트
- **체크섬**: 데이터그램 전송 과정에서 오류 발생 여부를 검사하기 위한 필드. 수신지는 이 필드의 값을 토대로 데이터그램의 정보가 훼손되었는지를 판단하고, 문제가 있다고 판단한 데이터그램은 폐기한다.


UDP는 주로 실시간 스트리밍 서비스, 인터넷 전화 등 실시간성이 강조되는 상황에서 많이 사용된다.


-----

# 3. TCP의 오류/흐름/혼잡 제어

TCP는 재전송을 기반으로 다양한 오류를 제어하고, 흐름 제어를 통해 처리할 수 있을 만큼의 데이터만 주고 받고, 혼잡 제어를 통해 네트워크가 혼잡한 정도에 따라 전송량을 조절한다.

## 오류 제어:재전송 기법

### 오류 검출과 재전송

TCP가 오류를 검출하고 세그먼트를 재전송하는 상황은 다음과 같이 2가지 경우가 있다.

#### 1. 중복된 ACK 세그먼트 수신

수신 호스트 측이 받은 세그먼트 순서 번호 중 일부가 누락되었다면 중복된 ACK 세그먼트를 보낸다.

>RTT(Round Trip Time) - 메시지를 전송한 뒤 답변을 받는데까지 걸리는 시간

#### 2. 타임 아웃 발생

TCP 세그먼트 송신 호스트는 재전송 타이머라는 값을 유지한다. 이 타이머의 카운트다운이 끝났을 때를 **타임아웃**이라고 한다.

타임아웃이 발생하면 상대 호스트에게 세그먼트가 정상적으로 도착하지 않았다고 판단하여 재전송한다.


### ARQ: 재전송 기법

문제가 생긴 메시지를 재전송하여 신뢰성을 확보하는 방식을 **ARQ(Automatic Repeat Request, 자동 재전송 요구)**라고 한다.

대표적으로 다음 방식이 있다. 

- Stop-and-Wait ARQ
- Go-Bakc-N ARQ
- Selective Repeat ARQ


### Stop-and-Wait ARQ

해당 방식은 제대로 전달했음을 확인하기 전까지는 새로운 메시지를 보내지 않는 방식이다.

메시지 송신, 확인 응답 받는 과정을 반복하다.

확인 응답을 받기 전까지 다음 전송이 가능해도 하지 못하고 수신 호스트도 전송 받을 수 있음에도 하나씩만 확인 응답을 해야된다. 따라서 네트워크 이용 효율이 낮아지고 성능 저하로 이어질 수 있다.
(오늘날 잘 사용하지 않는다.)

### Go-Back-N ARQ

연속해서 메시지를 전송할 수 있는 기술이 파이프라이닝을 통해 ACK 세그먼트가 도착하기 전에 여러 세그먼트는 보낸다.
![](https://velog.velcdn.com/images/holim0/post/22b6f1ae-bc60-4c7e-84d9-e0b6ff509a3f/image.png)

해당 방식은 여러 세그먼트를 전송하고 도중에 잘못 전송된 세그먼트가 있을 경우 해당 세그먼트부터 다시 전송하는 방식이다. (그 외 모든 세그먼트 폐기)

Go-Back-N ARQ의 ACK 세그먼트를 **누적 확인 응답**이라고 한다. (N번까지의 확인 응답이기 때문에)


>**빠른 재전송**
재전송 타이머가 만료되가 전이라도 세 번의 동일한 ACK 세그먼트가 수신되었다면 세그먼트를 곧바로 재전송하는 기능이다.

### Selective Repeat ARQ

해당 방식은 선택적으로 재전송하는 기법으로 수신 호스트 측에서 제대로 전송받은 패킷들에 대해 ACK 세그먼트를 보내는 방식이다.

따라서 ACK 세그먼트는 **개별 확인 응답**이다.![](https://velog.velcdn.com/images/holim0/post/66f5f97b-e2e0-403b-849b-ae0c1656c215/image.png)

오늘날 대부분의 호스트는 TCP 통신에서 해당 방식을 지원한다. 만약 지원하지 않는다면 Go-Back-N ARQ 방식으로 동작한다.



## 흐름 제어: 슬라이딩 윈도우

호스트가 한 번에 받아서 처리할 수 있는 세그먼트의 양에는 한계가 있어 파프라이닝 기반으로 세그먼트를 주고 받을 때 **흐름 제어**가 중요하다.

- 수신 버퍼 - 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽리기 전 임시 저장되는 공간

- 버퍼 오버플로 - 수신 버퍼의 크기보다 많은 데이터를 저장하려고 할 때 발생


TCP에서는 흐름 제어로 **슬라이딩 윈도우**를 사용한다.

윈도우란 **송신 호스트가 파이프라이닝할 수 있는 최대량**을 의미한다.(확인 응답 없이 한 번에 전송 가능)![](https://velog.velcdn.com/images/holim0/post/d4c85b1a-1ec9-4ced-9dc6-28341f235f6b/image.png)

송신 측 윈도우는 수신 호스트가 알려 주는 수신 측 윈도우를 토대로 알 수 있는 정보이다.

수신 포스트는 TCP 헤더(윈도우 필드)를 통해 송신 호스트에게 받아들일 수 있는 데이터의 양(윈도우 사이즈)를 알린다.

수신 호스트가 첫 번째 세그먼트를 올바르게 수신했으면 수신 윈도우도 오른쪽으로 한 칸 이동한다.![](https://velog.velcdn.com/images/holim0/post/a5c0394b-0127-47ae-bd10-a8b49cb16ded/image.png)



## 혼잡 제어

혼잡이란? 많은 트래픽으로 인해 패킷의 처리 속도가 늦어지거나 유실될 우려가 있는 네트워크 상황이다.

TCP의 혼잡 제어란 이와 같은 혼잡을 제어하기 위한 기능이다. **흐름 제어의 주제는 수신 호스트라면, 혼잡 제어의 주체는 송신 호스트이다.**

송신 호스트는 네트워크 혼잡도를 판단하고 혼잡 정도에 맞춰 유동적으로 전송량을 조절한다.

- **혼잡 윈도우(Congestion Window, cwnd)** - 혼잡 없이 전송할 수 있는 데이터양, 송신 호스트가 혼잡을 방지할 수 있는 윈도우 사이즈를 계산해야 된다.


혼잡 윈도우 크기는 혼잡 제어 알고리즘을 통해 결정할 수 있다. 하나씩 살펴보자.


#### 1. AIMD(Additive Increase/Multiplicative Decrease)

합 증가, 곱 감소로 혼잡이 감지되지 않으면 RTT 마다 혼잡 윈도우 크기를 1씩 증가시키고 혼잡이 감지되면 혼잡 윈도우 크기를 절반으로 줄인다.



#### 2. 느린 시작 알고리즘

혼잡 윈도우를 1부터 시작해 문제없이 수신된 ACK 세그먼트당 1씩 증가시키는 방법이다. RTT 마다 2배씩 지수적으로 증가한다.![](https://velog.velcdn.com/images/holim0/post/87bbe084-dc71-483d-84ee-5ab270d941b8/image.png)

지수적으로 혼잡 윈도우를 계속해서 증가시킬 수는 없을 것이다. 따라서 느린 시작 알고리즘을 사용할 때 **느린 시작 임계치**라는 값을 사용한다.

다음 표를 참고하자.

| 상황 분류           | 방법                                                                 |
|--------------------|--------------------------------------------------------------------|
| 타임아웃 발생       | 혼잡 윈도우 값을 1로, 느린 시작 임계치를 혼잡이 감지되었을 시점의 혼잡 윈도우 값의 절반으로 초기화한 뒤 **느린 시작** 재개 |
| 혼잡 윈도우 >= 느린 시작 임계치 | 느린 시작 종료, **혼잡 회피** 수행                |
| 세 번의 중복 ACK 발생 | (빠른 재전송 후) **빠른 회복** 수행                                               |

#### 3. 혼잡 회피 알고리즘

RTT마다 혼잡 윈도우를 1MSS(Maximum Segment Size)씩 증가시키는 알고리즘이다. 선형적으로 윈도우 사이즈가 증가한다.

느린 시작 임계치를 넘어선 시점부터 적용되는 알고리즘이다.
![](https://velog.velcdn.com/images/holim0/post/f620c9e8-dd99-4d17-91f5-a32e7c0972d2/image.png)

혼잡 회피 중 타임아웃이 발생하면 혼잡 윈도우 값은 1로 되고 느린 시작 임계치는 혼잡이 감지된 시점의 혼잡 윈도우 값의 절반으로 초기화한 뒤 다시 느린 시작을 수행한다.

#### 4. 빠른 회복 알고리즘

빠른 회피 알고리즘은 세 번의 중복 ACK 세그먼트를 수신했을 때 느린 시작은 건너뛰고 혼잡 회피를 수행하는 알고리즘이다. (빠른 재전송도 이뤄진다.)

빠른 전송률을 회복하기 위한 알고리즘이다. 다만, 빠른 회복 도중 타임아웃이 발생하면 혼잡 윈도우 크기는 1로, 느린 시작 임계치는 혼잡이 감지된 절반으로 되고 다시 느린 시작을 수행한다.


![](https://velog.velcdn.com/images/holim0/post/abc8ddf4-d5a1-4c07-86d4-597a728b66ad/image.png)







